C51 COMPILER V9.00   KEY                                                                   11/07/2015 14:53:12 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN ..\out\obj\key.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE ..\source\key.c LARGE BROWSE INCDIR(..\OS;..\include) DEBUG O
                    -BJECTEXTEND PRINT(..\out\list\key.lst) OBJECT(..\out\obj\key.obj)

line level    source

   1          #include "sys.h"
   2          #include "key.h"
   3          #include "uart.h"
   4          #include "timer.h"
   5          #include "led.h"
   6          #include "tone.h"
   7          #include "eeprom.h"
   8          #include "WIFI.h"
   9          #include "power.h"
  10          
  11          ///////////////////////////SOS key///////////////////////////////////////
  12          void Key1Init(void)
  13          {
  14   1              AUXR2 &= 0xEF; //CLOSE EXT2 INTERRUPT
  15   1              P3M1 |= 0x40;
  16   1              P3M0 &= 0xBF;
  17   1              g_SystemVar.Key1Status = KEY_PAD_IDLE_STATE;
  18   1      
  19   1              SysTaskEnable(SCAN_KEY_1_TASK_ID, SYS_RUN_TASK_IMMEDIATELY);
  20   1      }
  21          
  22          TaskTimeout_t ScanKey1(void)
  23          {
  24   1              bit KeyStatus;
  25   1              TaskTimeout_t cTimeToRun;
  26   1              
  27   1              cTimeToRun = SYS_RUN_TASK_IMMEDIATELY;
  28   1              switch(g_SystemVar.Key1Status)
  29   1              {
  30   2                      case KEY_PAD_IDLE_STATE:
  31   2                              SysPrintf("\r\nKEY_PAD_IDLE_STATE.");
  32   2                              KeyStatus = p_S1;
  33   2                              g_SystemVar.Key1DebounceCounter = 0;
  34   2                              if(KeyStatus == KEY_RELEASE)
  35   2                              {
  36   3                                      g_SystemVar.Key1Status = KEY_PAD_SCAN_GPIO_STATE;
  37   3                              }
  38   2                              break;
  39   2                              
  40   2                      case KEY_PAD_SCAN_GPIO_STATE:
  41   2                              KeyStatus = p_S1;
  42   2                              if(KeyStatus == KEY_PRESS)
  43   2                              {
  44   3                                      g_SystemVar.Key1Status = KEY_PAD_DEBOUNCE_STATE;
  45   3                              }
  46   2                              break;
  47   2                              
  48   2                      case KEY_PAD_DEBOUNCE_STATE:
  49   2                              KeyStatus = p_S1;
  50   2                              if(KeyStatus == KEY_PRESS)
  51   2                              {
  52   3                                      g_SystemVar.Key1DebounceCounter++;
  53   3                                      if(g_SystemVar.Key1DebounceCounter == KEY_SCAN_DEBOUNCE_COUNT)
  54   3                                      {
C51 COMPILER V9.00   KEY                                                                   11/07/2015 14:53:12 PAGE 2   

  55   4                                              g_SystemVar.Key1Status = KEY_PAD_WAIT_RELEASE_STATE;
  56   4                                      }       
  57   3                              }
  58   2                              else
  59   2                              {
  60   3                                      g_SystemVar.Key1Status = KEY_PAD_SCAN_END_STATE;
  61   3                              }
  62   2                              break;
  63   2                              
  64   2                      case KEY_PAD_WAIT_RELEASE_STATE:
  65   2                              KeyStatus = p_S1;
  66   2                              if(KeyStatus == KEY_RELEASE)
  67   2                              {
  68   3                                      g_SystemVar.Key1Status = KEY_PAD_SCAN_END_STATE;
  69   3                                      if(g_SystemVar.Key1DebounceCounter < KEY_SCAN_LONG_PRESS_TIMEOUT)
  70   3                                      {
  71   4                                              HostMsgPost(SYS_MSG_KEY_PRESS, SYS_MSG_KEY1_PRESS);
  72   4                                      }       
  73   3                              }
  74   2                              else
  75   2                              {
  76   3                                      if(g_SystemVar.Key1DebounceCounter < KEY_SCAN_LONG_PRESS_TIMEOUT)
  77   3                                              g_SystemVar.Key1DebounceCounter++;
  78   3                                      if(g_SystemVar.Key1DebounceCounter == KEY_SCAN_LONG_PRESS_TIMEOUT)
  79   3                                      {
  80   4                                              g_SystemVar.Key1DebounceCounter++;
  81   4                                              HostMsgPost(SYS_MSG_KEY_PRESS, SYS_MSG_KEY1_LONG_PRESS);
  82   4                                      }
  83   3                              }
  84   2                              break;
  85   2                              
  86   2                      case KEY_PAD_SCAN_END_STATE:
  87   2                              g_SystemVar.Key1Status = KEY_PAD_IDLE_STATE;
  88   2                              break;                  
  89   2              }
  90   1              
  91   1              return cTimeToRun;
  92   1      }
  93          ///////////////////////REGISTER KEY//////////////////////////////////////////
  94          void Key2Init(void)
  95          {
  96   1              P3M1 |= 0x20;
  97   1              P3M0 &= 0xdF;
  98   1              
  99   1              g_SystemVar.Key2Status = KEY_PAD_IDLE_STATE;
 100   1              g_SystemVar.Key2DebounceCounter = 0;
 101   1              SysTaskEnable(SCAN_KEY_2_TASK_ID, SYS_RUN_TASK_IMMEDIATELY);
 102   1      }
 103          
 104          TaskTimeout_t ScanKey2(void)
 105          {
 106   1              bit KeyStatus;
 107   1              TaskTimeout_t cTimeToRun;
 108   1              
 109   1              cTimeToRun = SYS_RUN_TASK_IMMEDIATELY;
 110   1              switch(g_SystemVar.Key2Status)
 111   1              {
 112   2                      case KEY_PAD_IDLE_STATE:
 113   2                              KeyStatus = p_S2;
 114   2                              g_SystemVar.Key2DebounceCounter = 0;
 115   2                              if(KeyStatus == KEY_RELEASE)
 116   2                              {
C51 COMPILER V9.00   KEY                                                                   11/07/2015 14:53:12 PAGE 3   

 117   3                                      g_SystemVar.Key2Status = KEY_PAD_SCAN_GPIO_STATE;
 118   3                              }
 119   2                              break;
 120   2                              
 121   2                      case KEY_PAD_SCAN_GPIO_STATE:
 122   2                              KeyStatus = p_S2;
 123   2                              if(KeyStatus == KEY_PRESS)
 124   2                              {
 125   3                                      g_SystemVar.Key2Status = KEY_PAD_DEBOUNCE_STATE;
 126   3                              }
 127   2                              break;
 128   2                              
 129   2                      case KEY_PAD_DEBOUNCE_STATE:
 130   2                              KeyStatus = p_S2;
 131   2                              if(KeyStatus == KEY_PRESS)
 132   2                              {
 133   3                                      g_SystemVar.Key2DebounceCounter++;
 134   3                                      if(g_SystemVar.Key2DebounceCounter == KEY_SCAN_DEBOUNCE_COUNT)
 135   3                                      {
 136   4                                              g_SystemVar.Key2Status = KEY_PAD_WAIT_RELEASE_STATE;
 137   4                                      }
 138   3                              }
 139   2                              else
 140   2                              {
 141   3                                      g_SystemVar.Key2Status = KEY_PAD_SCAN_END_STATE;
 142   3                              }
 143   2                              break;
 144   2                              
 145   2                      case KEY_PAD_WAIT_RELEASE_STATE:
 146   2                              KeyStatus = p_S2;
 147   2                              if(KeyStatus == KEY_RELEASE)
 148   2                              {
 149   3                                      g_SystemVar.Key2Status = KEY_PAD_SCAN_END_STATE;
 150   3                                      if(g_SystemVar.Key2DebounceCounter < KEY_SCAN_LONG_PRESS_TIMEOUT)
 151   3                                      {
 152   4                                              HostMsgPost(SYS_MSG_KEY_PRESS, SYS_MSG_KEY2_PRESS);
 153   4                                      }
 154   3                              }
 155   2                              else
 156   2                              {
 157   3                                      if(g_SystemVar.Key2DebounceCounter < KEY_SCAN_LONG_PRESS_TIMEOUT)
 158   3                                              g_SystemVar.Key2DebounceCounter++;
 159   3                                      if(g_SystemVar.Key2DebounceCounter==KEY_SCAN_LONG_PRESS_TIMEOUT)
 160   3                                      {
 161   4                                              g_SystemVar.Key2DebounceCounter++;
 162   4                                              HostMsgPost(SYS_MSG_KEY_PRESS, SYS_MSG_KEY2_LONG_PRESS);
 163   4                                      }
 164   3                              }
 165   2                              break;
 166   2                              
 167   2                      case KEY_PAD_SCAN_END_STATE:
 168   2                              g_SystemVar.Key2Status = KEY_PAD_IDLE_STATE;
 169   2                              break;                  
 170   2              }
 171   1              
 172   1              return cTimeToRun;
 173   1      }
 174          
 175          void KeyInit(void)
 176          {
 177   1              Key1Init();
 178   1              Key2Init();
C51 COMPILER V9.00   KEY                                                                   11/07/2015 14:53:12 PAGE 4   

 179   1      }
 180          
 181          void KeyPadHandler(MSG_t *pMsg)
 182          {
 183   1              switch(pMsg->Param)
 184   1              {
 185   2                      case SYS_MSG_KEY2_PRESS:
 186   2                              if(g_SystemVar.ACStatus == POWER_DC_IN)
 187   2                              {
 188   3                                      if(g_WifiVar.cSetConnectApFlag == FALSE)
 189   3                                      {
 190   4                                              HostMsgPost(SYS_MSG_WIFI_SET_AP_CONNECTED, NULL);
 191   4                                      }
 192   3                                      else
 193   3                                      {
 194   4                                              HostMsgPost(SYS_MSG_WIFI_EXIT_SET_AP_CONNECTED, NULL);
 195   4                                      }
 196   3                              }
 197   2                              BeepTone(BEEP_NORMAL);
 198   2                              SysPrintf("\r\nSYS_MSG_KEY2_PRESS");
 199   2                              break;
 200   2      
 201   2                      case SYS_MSG_KEY1_PRESS:
 202   2                              if(g_SystemVar.SystemCurrentStatus == SYSTEM_RF_REGISTER_STATUS)
 203   2                              {
 204   3                                      HostMsgPost(SYS_MSG_LEFT_CURRENT_STATUS, g_SystemVar.SystemLastStatus); 
 205   3                              }
 206   2                              else
 207   2                              {
 208   3                                      HostMsgPost(SYS_MSG_LEFT_CURRENT_STATUS, SYSTEM_RF_REGISTER_STATUS);
 209   3                              }
 210   2                              BeepTone(BEEP_NORMAL);
 211   2                              break;
 212   2                              
 213   2                      case SYS_MSG_KEY2_LONG_PRESS:
 214   2                              SysPrintf("\r\nSYS_MSG_KEY2_LONG_PRESS");
 215   2                              HostMsgPost(SYS_MSG_POWER_OFF, NULL);
 216   2                              BeepTone(BEEP_NORMAL);
 217   2                              break;
 218   2                              
 219   2                      case SYS_MSG_KEY1_LONG_PRESS:
 220   2                              SysPrintf("\r\nSYS_MSG_KEY1_LONG_PRESS");
 221   2                              EE_Data_Default();
 222   2                              BeepTone(BEEP_CONFIRM);
 223   2                              HostMsgPost(SYS_MSG_WIFI_DEFAULT, NULL);
 224   2                              break;                  
 225   2              }
 226   1              
 227   1      }
 228          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    541    ----
   CONSTANT SIZE    =     95    ----
   XDATA SIZE       =   ----       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
