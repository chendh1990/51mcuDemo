C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN ..\out\obj\uart.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE ..\source\uart.c LARGE BROWSE INCDIR(..\OS;..\include) DEBUG 
                    -OBJECTEXTEND PRINT(..\out\list\uart.lst) OBJECT(..\out\obj\uart.obj)

line level    source

   1          #include "sys.h"
   2          #include "uart.h"
   3          #include "eeprom.h"
   4          #include "WIFI.h"
   5          #include "RF_remote.h"
   6          #include "SysClk.h"
   7          
   8          xdata uart_var_t g_sUart[UART_NUMBER];
   9          uchar xdata g_cUart1ReceiveBuf[UART1_BUFFER_SIZE];
  10          uchar xdata g_cUart2ReceiveBuf[UART_WIFI_BUFFER_SIZE];
  11          code uchar  HEX[]="0123456789ABCDEF";
  12          
  13          void ClearUartBuffer(uart_number_t eUartNo)
  14          {
  15   1              g_sUart[eUartNo].iPushIndex = 0;
  16   1              memset(g_sUart[eUartNo].cReveiveBuf, 0, eUartNo == UART_WIFI ? UART_WIFI_BUFFER_SIZE : UART1_BUFFER_SIZE)
             -;
  17   1      }
  18          
  19          void UartOpen(uart_number_t eUartNo)    
  20          {
  21   1              if(eUartNo == UART_PC)
  22   1              {
  23   2                      g_sUart[UART_PC].cReveiveBuf = g_cUart1ReceiveBuf;
  24   2              }
  25   1              else    
  26   1              {
  27   2                      g_sUart[UART_WIFI].cReveiveBuf = g_cUart2ReceiveBuf;
  28   2              }
  29   1      
  30   1              g_sUart[eUartNo].iPopIndex = 0;
  31   1              g_sUart[eUartNo].iPushIndex = 0;
  32   1              g_sUart[eUartNo].bRxControl = ENABLE;
  33   1              g_sUart[eUartNo].bRxStart = TRUE;
  34   1      }
  35          
  36          void UartInit(void)
  37          {
  38   1              ACC = P_SW1;
  39   1              ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
  40   1              P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD) 
  41   1              P_SW2 &= 0Xfe;            
  42   1              S2CON = 0x50;
  43   1              IE2 = 0x01;    
  44   1              IP2 |= 0X01;
  45   1              T2L = (65536 - (FOSC/4/BAUD_115200)); 
  46   1              T2H = (65536 - (FOSC/4/BAUD_115200))>>8;
  47   1              AUXR |= 0x14;    
  48   1      ////////////////////////////////
  49   1              SCON = 0X50;
  50   1              AUXR |= 0x01;           
  51   1              ES = 1;                    
  52   1      //      EA = 1; 
  53   1      ///////////////////////////////////
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 2   

  54   1              UartOpen(UART_PC);
  55   1              UartOpen(UART_WIFI);
  56   1      }
  57          
  58          void Uart1ISR(void) interrupt 4
  59          {
  60   1              if(RI==1)
  61   1              {
  62   2                      RI = 0;
  63   2                      if(g_sUart[UART_PC].bRxControl == ENABLE)
  64   2                      {
  65   3                              g_sUart[UART_PC].cRxFrameOverCount = UART_RX_TIMEOUT;
  66   3                              if(g_sUart[UART_PC].bRxStart == TRUE)
  67   3                              {
  68   4                                      g_sUart[UART_PC].bRxStart = FALSE;
  69   4                                      g_sUart[UART_PC].iPushIndex = 0;
  70   4                              }
  71   3                              if(g_sUart[UART_PC].iPushIndex < UART1_BUFFER_SIZE)
  72   3                              {
  73   4                                      g_sUart[UART_PC].cReveiveBuf[g_sUart[UART_PC].iPushIndex++] = SBUF;
  74   4                              }
  75   3                      }       
  76   2              }
  77   1              else if(TI==1)
  78   1              {
  79   2                      TI = 0;
  80   2                      g_sUart[UART_PC].bTxOver = TRUE;
  81   2              }
  82   1                      
  83   1      }
  84          
  85          void Uart2ISR(void) interrupt 8
  86          {
  87   1              if(S2CON & S2RI)
  88   1              {
  89   2                      S2CON &= ~S2RI;
  90   2                      if(g_sUart[UART_WIFI].bRxControl == ENABLE)
  91   2                      {
  92   3                              g_sUart[UART_WIFI].cRxFrameOverCount = UART_RX_TIMEOUT;
  93   3                              if(g_sUart[UART_WIFI].bRxStart == TRUE)
  94   3                              {
  95   4                                      g_sUart[UART_WIFI].bRxStart = FALSE;
  96   4                                      g_sUart[UART_WIFI].iPushIndex = 0;
  97   4                              }
  98   3                              if(g_sUart[UART_WIFI].iPushIndex < UART_WIFI_BUFFER_SIZE)
  99   3                              {
 100   4                                      g_sUart[UART_WIFI].cReveiveBuf[g_sUart[UART_WIFI].iPushIndex++] = S2BUF;
 101   4                              }
 102   3                      }                       
 103   2              }
 104   1              else if(S2CON & S2TI)
 105   1              {
 106   2                      S2CON &= ~S2TI;
 107   2                      g_sUart[UART_WIFI].bTxOver = TRUE;
 108   2              }
 109   1      }
 110          
 111          void UartTickCheck(uart_number_t eUartNo)
 112          {       
 113   1              if(g_sUart[eUartNo].cRxFrameOverCount > 0)
 114   1              {
 115   2                      if(--g_sUart[eUartNo].cRxFrameOverCount == 0)
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 3   

 116   2                      {
 117   3                              g_sUart[eUartNo].bRxControl = DISABLE;
 118   3                              HostMsgPost(SYS_MSG_RECEIVE_DATA_FROM_USART, eUartNo);
 119   3                      }
 120   2              }
 121   1      
 122   1              if(g_sUart[eUartNo].cTxTimeOut > 0)
 123   1              {
 124   2                      g_sUart[eUartNo].cTxTimeOut--;
 125   2              }
 126   1      }
 127          //////////////////////////////////////////////////////////////////////////////
 128          void UartSendByte(uart_number_t eUartNo, uchar cData)
 129          {
 130   1              g_sUart[eUartNo].cTxTimeOut = UART_TX_TIMEOUT;
 131   1              g_sUart[eUartNo].bTxOver = FALSE;
 132   1              if(eUartNo == UART_PC)
 133   1              {
 134   2                      SBUF = cData;
 135   2              }       
 136   1              else if(eUartNo == UART_WIFI)
 137   1              {
 138   2                      S2BUF = cData;
 139   2              }
 140   1              
 141   1              while(1)
 142   1              {
 143   2                      if((g_sUart[eUartNo].bTxOver==TRUE) || (g_sUart[eUartNo].cTxTimeOut == 0))
 144   2                              return;
 145   2              }
 146   1      }
 147          
 148          void UartSendString(uchar dev,uchar *pData)
 149          {
 150   1              uint cCount;
 151   1              
 152   1              cCount = 0;
 153   1              while(1)
 154   1              {
 155   2                      if((*pData == '\0')||(*pData == END_FLAG)||(cCount++ > 500))
 156   2                              break;
 157   2                      UartSendByte(dev, *pData++);
 158   2              }
 159   1      }
 160          
 161          void UartSendEnterString(uchar dev,uchar *pData)
 162          {
 163   1              uchar cCount;
 164   1              
 165   1              cCount = 0;
 166   1              while(1)
 167   1              {
 168   2                      if(cCount++ == 254)
 169   2                              break;
 170   2      
 171   2                      if((*pData=='\r')&&(*(pData+1)=='\n'))
 172   2                      //if((*pData==0x0d)&&(*(pData+1)==0x0a))        
 173   2                      {
 174   3                              break;
 175   3                      }       
 176   2                      UartSendByte(dev, *pData);
 177   2                      pData++;
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 4   

 178   2              }
 179   1      } 
 180          
 181          void UartSendWcharString(uchar dev,uchar *pData)
 182          {
 183   1              uchar cCount;
 184   1              
 185   1              cCount = 0;
 186   1              while(1)
 187   1              {
 188   2                      if(cCount++ == 255)
 189   2                              break;
 190   2                      if((*pData==END_FLAG)&&(*(pData+1)==END_FLAG))
 191   2                              break;
 192   2                      UartSendByte(dev, *pData);
 193   2                      pData++;
 194   2                      UartSendByte(dev, *pData);
 195   2                      pData++;
 196   2              }
 197   1      } 
 198          
 199          void UartSendData(uchar dev,uchar *pData,uchar cLenght)
 200          {
 201   1              uchar cIndex;
 202   1      
 203   1              for(cIndex=0; cIndex<cLenght; cIndex++)
 204   1              {
 205   2                      UartSendByte(dev, *pData++);
 206   2              }
 207   1      }
 208          
 209          uchar IntToStr(uchar *pStr, uint iVal, data_type_t eDataType)
 210          {
 211   1              uchar cIndex;
 212   1              uchar cStr[MAX_INT_DEC_LENGTH];
 213   1              uchar cDataWidth;
 214   1              uchar cTemp;
 215   1              uint iTemp;
 216   1      
 217   1              cDataWidth = 0;
 218   1              if(eDataType == DEC_TYPE)
 219   1              {
 220   2                      iTemp = 10000;
 221   2                      for(cIndex=0; cIndex<MAX_INT_DEC_LENGTH; cIndex++)
 222   2                      {
 223   3                              if(cIndex<(MAX_INT_DEC_LENGTH-1))
 224   3                              {
 225   4                                      cTemp = iVal/iTemp;
 226   4                                      iVal = iVal%iTemp;
 227   4                                      cStr[cIndex] = HEX[cTemp];
 228   4                              }       
 229   3                              else
 230   3                                      cStr[cIndex] = HEX[iVal];
 231   3                              if(cDataWidth == 0)
 232   3                              {
 233   4                                      if(cStr[cIndex] != '0')
 234   4                                      {
 235   5                                              cDataWidth = MAX_INT_DEC_LENGTH - cIndex;
 236   5                                      }
 237   4                              }
 238   3                              
 239   3                              iTemp /= 10;
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 5   

 240   3                      }
 241   2                      if(cDataWidth == 0)
 242   2                      {
 243   3                              cDataWidth = 1;
 244   3                      }
 245   2                      memcpy(pStr, cStr+MAX_INT_DEC_LENGTH-cDataWidth, cDataWidth);
 246   2              }       
 247   1              else if(eDataType == HEX_TYPE)
 248   1              {               
 249   2                      if(iVal > 0xff)
 250   2                      {
 251   3                              cDataWidth = 4;
 252   3                              *pStr++ = HEX[(iVal>>12)&0x0f];
 253   3                              *pStr++ = HEX[(iVal>>8)&0x0f];
 254   3                              *pStr++ = HEX[(iVal>>4)&0x0f];
 255   3                              *pStr++ = HEX[iVal&0x0f];
 256   3                      }
 257   2                      else
 258   2                      {
 259   3                              cDataWidth = 2;
 260   3                              *pStr++ = HEX[(iVal>>4)&0x0f];
 261   3                              *pStr++ = HEX[iVal&0x0f];                       
 262   3                      }
 263   2              }
 264   1              return cDataWidth;
 265   1      }
 266          
 267          void UsartPrint(uart_number_t dev,  uchar *pFormat, va_list vallist)
 268          {
 269   1              uchar pTemp[5];
 270   1              uchar cRetVal;
 271   1              uint iArg;
 272   1              uchar cArg;
 273   1              uchar *cStr;
 274   1              
 275   1              while(1)
 276   1              {
 277   2                      if(*pFormat == '%')
 278   2                      {
 279   3                              pFormat++;
 280   3                              if(*pFormat == 'd')
 281   3                              {       
 282   4                                      if(*(pFormat+1) == 'i')
 283   4                                      {
 284   5                                              pFormat++;
 285   5                                              iArg = va_arg(vallist,  uint);
 286   5                                      }
 287   4                                      else
 288   4                                              iArg = va_arg(vallist,  uchar);
 289   4                                      cRetVal = IntToStr(pTemp, iArg, DEC_TYPE);
 290   4                                      UartSendData(dev, pTemp, cRetVal);
 291   4                              }
 292   3                              else if(*pFormat == 'x')
 293   3                              {
 294   4                                      if(*(pFormat+1) == 'i')
 295   4                                      {
 296   5                                              pFormat++;
 297   5                                              iArg = va_arg(vallist,  uint);
 298   5                                      }       
 299   4                                      else
 300   4                                              iArg = va_arg(vallist,  uchar);
 301   4                                      cRetVal = IntToStr(pTemp, iArg, HEX_TYPE);
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 6   

 302   4                                      UartSendData(dev, pTemp, cRetVal);
 303   4                              }
 304   3                              else if(*pFormat == 'c')
 305   3                              {
 306   4                                      cArg = va_arg(vallist,  uchar );
 307   4                                      UartSendByte(dev, cArg);
 308   4                              }               
 309   3                              else if(*pFormat == 's')
 310   3                              {
 311   4                                      cStr = va_arg(vallist,  uchar *);
 312   4                                      UartSendString(dev, cStr);
 313   4                              }
 314   3                              else if(*pFormat == 'e')
 315   3                              {
 316   4                                      cStr = va_arg(vallist,  uchar *);
 317   4                                      UartSendEnterString(dev, cStr);
 318   4                              }       
 319   3                              else if(*pFormat == 'u')
 320   3                              {
 321   4                                      cStr = va_arg(vallist,  uchar *);
 322   4                                      UartSendWcharString(dev, cStr);
 323   4                                      break;
 324   4                              }       
 325   3                              else if(*pFormat == 'l')
 326   3                              {
 327   4                                      cStr = va_arg(vallist,  uchar *);
 328   4                                      UartSendData(dev, (cStr+1), *cStr);
 329   4                              }
 330   3                              
 331   3                      }
 332   2                      else if(*pFormat == '\0')
 333   2                      {
 334   3                              break;
 335   3                      }
 336   2                      else
 337   2                      {
 338   3                              UartSendByte(dev, *pFormat);
 339   3                      }
 340   2                      pFormat++;
 341   2              }
 342   1      }
 343          
 344          void SysPrintf( uchar *pFormat, ...)
 345          {
 346   1              if(g_SystemParam.DebugInforOutput == ENABLE)
 347   1              {
 348   2                      va_list vallist;
 349   2                      
 350   2                      OSSemPend(SEM_PRINTF,0);        
 351   2                      va_start(vallist,pFormat);
 352   2                      UsartPrint(UART_PC, pFormat, vallist);
 353   2                      va_end(vallist);
 354   2                      OSSemPost(SEM_PRINTF);
 355   2              }
 356   1      }
 357          
 358          void CmdInquery(void)
 359          {
 360   1              if(g_sUart[UART_PC].iPushIndex > 1)
 361   1                      return;
 362   1              OSSemPend(SEM_PRINTF,0);        
 363   1              UartSendString(UART_PC, "\r\nUart command list below:");
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 7   

 364   1              UartSendString(UART_PC, "\r\n[A]: Print all of system parameters.");
 365   1              UartSendString(UART_PC, "\r\n[B]: print GPIO status.");
 366   1              UartSendString(UART_PC, "\r\n[C]: Set server address, e.g \"C192.168.001.015:8800\": store the server IP 
             -address \"192.168.1.15\" and port number \"8800\" to host.");
 367   1              UartSendString(UART_PC, "\r\n[D]: Set siren mute(D0.mute on D1.mute off).");
 368   1              UartSendString(UART_PC, "\r\n[E]: Debug WIFI module, e.g \"EAT\": send \"AT\" to WIFI module.");
 369   1              UartSendString(UART_PC, "\r\n[F]: print on.");
 370   1              UartSendString(UART_PC, "\r\n[G]: print off.");
 371   1              OSSemPost(SEM_PRINTF);
 372   1      }
 373          ///////////////////////////////////////////////////////////////////////////
 374          void PrintParam(void)
 375          {
 376   1              if(g_sUart[UART_PC].iPushIndex > 1)
 377   1                      return; 
 378   1              SysPrintf("\r\nF/W version is %xi and Compiled at %s, %s", SOFTWARE_VERSION, __DATE__, __TIME__);
 379   1              SysPrintf( "\r\nSystem status: %d ( 1.Disarm 2.Arm 3.At home arm ).", g_SystemParam.SystemStatus);
 380   1              SysPrintf( "\r\nPower supply mode: %d ( 0.Battery 1.AC/DC Adaptor ).", g_SystemVar.ACStatus);
 381   1              SysPrintf( "\r\nSiren mute status: %d ( 0.Mute on 1.Mute off ).", g_SystemParam.SirenMuteFlag);
 382   1              SysPrintf( "\r\nSystem password: %c%c%c%c.", g_SystemParam.SystemPassword[0],g_SystemParam.SystemPassword
             -[1],g_SystemParam.SystemPassword[2],g_SystemParam.SystemPassword[3]); 
 383   1              SysPrintf( "\r\nHost ID: %x.%x.%x.", g_SystemParam.HostID[0],g_SystemParam.HostID[1],g_SystemParam.HostID
             -[2]);        
 384   1              SysPrintf( "\r\nHost mac address: %x:%x:%x:%x:%x:%x.", g_SystemParam.HostMacAdr[0],g_SystemParam.HostMacA
             -dr[1],g_SystemParam.HostMacAdr[2],g_SystemParam.HostMacAdr[3],g_SystemParam.HostMacAdr[4],g_SystemParam.HostMacAdr[5]);       
 385   1              SysPrintf( "\r\nHost IP address: %d.%d.%d.%d.", g_SystemParam.HostIPAdr[0],g_SystemParam.HostIPAdr[1],g_S
             -ystemParam.HostIPAdr[2],g_SystemParam.HostIPAdr[3]);
 386   1              SysPrintf( "\r\nHost sub mask address: %d.%d.%d.%d.", g_SystemParam.HostSubMask[0],g_SystemParam.HostSubM
             -ask[1],g_SystemParam.HostSubMask[2],g_SystemParam.HostSubMask[3]);
 387   1              SysPrintf( "\r\nHost gate address: %d.%d.%d.%d.", g_SystemParam.HostGate[0],g_SystemParam.HostGate[1],g_S
             -ystemParam.HostGate[2],g_SystemParam.HostGate[3]);
 388   1              SysPrintf( "\r\nTCP server address: %d.%d.%d.%d.", g_SystemParam.TcpIpServerAdr[0],g_SystemParam.TcpIpSer
             -verAdr[1],g_SystemParam.TcpIpServerAdr[2],g_SystemParam.TcpIpServerAdr[3]);   
 389   1              SysPrintf( "\r\nTCP Server port: %xi", g_SystemParam.TcpIpServerPort);
 390   1              SysPrintf( "\r\nUDP port: %xi", g_SystemParam.UdpLocalPort);
 391   1              SysPrintf( "\r\nSiren lasting time: %d minutes.", g_SystemParam.SirenLastingTime);
 392   1              SysPrintf( "\r\nDelay arm time: %d seconds.", g_SystemParam.DelayArmTime);
 393   1              SysPrintf( "\r\nDelay alarm time: %d seconds.", g_SystemParam.DelayAlarmTime);  
 394   1              SysPrintf( "\r\nAuto arm time: %xi", g_SystemParam.AutoArmTime);
 395   1              SysPrintf( "\r\nAuto disarm time: %xi.", g_SystemParam.AutoDisarmTime);         
 396   1              SysPrintf( "\r\nTotals of registered RC: %d", g_SystemParam.RegisteredRemoteNum);
 397   1              SysPrintf( "\r\nTotals of registered sensor: %d", g_SystemParam.RegisteredWirelessAccessoryNum);
 398   1              SysPrintf( "\r\nTotals of registered door bell: %d", g_SystemParam.RegisteredDoorBellNum);              
 399   1              SysPrintf( "\r\nTotals of history log: %d", g_SystemParam.HistoryLogNum);       
 400   1      
 401   1              SysPrintf( "\r\ng_SystemVar.UploadPlatformControl: %d", g_SystemVar.UploadPlatformControl);
 402   1              SysPrintf( "\r\ng_WifiVar.cResetTimeOut: %d", g_WifiVar.cResetTimeOut);
 403   1      #if 1
 404   1              {
 405   2                      uchar Index;
 406   2                      
 407   2                      SysPrintf( "\r\n RC CODE:");
 408   2                      EE_Read_Data(EE_REMOTE_CONTROL_START_ADDRESS, g_HostCommonBuf, 80);
 409   2                      for(Index=0; Index<80; Index++)
 410   2                      {
 411   3                              if((Index%8==0)&&(Index>0))
 412   3                                      SysPrintf( "\r\n RC CODE:");
 413   3                              SysPrintf( " %x", g_HostCommonBuf[Index]);
 414   3                              
 415   3                      }
 416   2                      SysPrintf( "\r\n RF ADR MAP:");
 417   2                      EE_Read_Data(EE_RF_ADDRESS_MAP_START, g_HostCommonBuf, 80);
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 8   

 418   2                      for(Index=0; Index<80; Index++)
 419   2                      {
 420   3                              if((Index%8==0)&&(Index>0))
 421   3                                      SysPrintf( "\r\n RC CODE:");
 422   3                              SysPrintf( " %x", g_HostCommonBuf[Index]);
 423   3                              
 424   3                      }
 425   2                      SysPrintf( "\r\n zone CODE:");
 426   2                      EE_Read_Data(EE_WIRELESS_ACCESSORY_START_ADDRESS, g_HostCommonBuf, 80);
 427   2                      for(Index=0; Index<80; Index++)
 428   2                      {
 429   3                              if((Index%8==0)&&(Index>0))
 430   3                                      SysPrintf( "\r\n RC CODE:");
 431   3                              SysPrintf( " %x", g_HostCommonBuf[Index]);
 432   3                      }
 433   2                      SysPrintf( "\r\n zone NAME:");
 434   2                      EE_Read_Data(EE_ZONE_NAME_FIRST_START_ADDRESS, g_HostCommonBuf, 128);
 435   2                      for(Index=0; Index<128; Index++)
 436   2                      {
 437   3                              if((Index%32==0)&&(Index>0))
 438   3                                      SysPrintf( "\r\n RC CODE:");
 439   3                              SysPrintf( " %x", g_HostCommonBuf[Index]);
 440   3                      }
 441   2                              
 442   2                      SysPrintf( "\r\n door bell CODE:");
 443   2                      EE_Read_Data(EE_WIRELESS_DOOR_BELL_START_ADDRESS, g_HostCommonBuf, 80);
 444   2                      for(Index=0; Index<80; Index++)
 445   2                      {
 446   3                              if((Index%8==0)&&(Index>0))
 447   3                                      SysPrintf( "\r\n RC CODE:");
 448   3                              SysPrintf( " %x", g_HostCommonBuf[Index]);
 449   3                      }               
 450   2              }
 451   1      #endif  
 452   1      }
 453          
 454          void GPIOStatus(void)
 455          {
 456   1              if(g_sUart[UART_PC].iPushIndex > 1)
 457   1                      return;
 458   1              SysPrintf( "\r\np_WIFI_LED: %c ", p_WIFI_LED==0?'0':'1');
 459   1              SysPrintf( "\r\np_SET_LED: %c ", p_SET_LED==0?'0':'1');
 460   1              SysPrintf( "\r\np_SOS_LED: %c ", p_SOS_LED==0?'0':'1');
 461   1              SysPrintf( "\r\np_9300_EN: %c ", p_9300_EN==0?'0':'1');
 462   1              SysPrintf( "\r\np_8002_EN: %c ", p_8002_EN==0?'0':'1');
 463   1              SysPrintf( "\r\np_RF_EN: %c ", p_RF_EN==0?'0':'1');
 464   1              SysPrintf( "\r\np_WIFI_RST: %c ", p_WIFI_RST==0?'0':'1');
 465   1              SysPrintf( "\r\np_WIFI_EN: %c ", p_WIFI_EN==0?'0':'1');
 466   1              SysPrintf( "\r\np_RF: %c ", p_RF==0?'0':'1');
 467   1              SysPrintf( "\r\np_AC: %c ", p_AC==0?'0':'1');
 468   1              SysPrintf( "\r\np_S1: %c ", p_S1==0?'0':'1');
 469   1              SysPrintf( "\r\np_S2: %c ", p_S2==0?'0':'1');   
 470   1      }
 471          
 472          void SetMuteStatus(void)
 473          {
 474   1              if((memcmp(g_sUart[UART_PC].cReveiveBuf, "D0", 2) == 0)
 475   1              ||(memcmp(g_sUart[UART_PC].cReveiveBuf, "D1", 2) == 0))
 476   1              {
 477   2                      SysPrintf("\r\nUart set siren mute status.");
 478   2                      g_SystemParam.SirenMuteFlag = g_sUart[UART_PC].cReveiveBuf[1] - '0';
 479   2                      SysParamToEeprom();
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 9   

 480   2              }
 481   1      }
 482          void SetIP(void)
 483          {
 484   1              uchar *pTemp;
 485   1              
 486   1              pTemp = g_sUart[UART_PC].cReveiveBuf + 1;
 487   1      
 488   1              g_SystemParam.TcpIpServerAdr[0] = ((*pTemp)-'0')*100 + (*(pTemp+1)-'0')*10 + (*(pTemp+2)-'0');
 489   1              pTemp += 4;
 490   1              g_SystemParam.TcpIpServerAdr[1] = ((*pTemp)-'0')*100 + (*(pTemp+1)-'0')*10 + (*(pTemp+2)-'0');
 491   1              pTemp += 4;
 492   1              g_SystemParam.TcpIpServerAdr[2] = ((*pTemp)-'0')*100 + (*(pTemp+1)-'0')*10 + (*(pTemp+2)-'0');
 493   1              pTemp += 4;
 494   1              g_SystemParam.TcpIpServerAdr[3] = ((*pTemp)-'0')*100 + (*(pTemp+1)-'0')*10 + (*(pTemp+2)-'0');
 495   1              pTemp += 4;
 496   1              g_SystemParam.TcpIpServerPort = ((*pTemp)-'0')*1000 + (*(pTemp+1)-'0')*100 + (*(pTemp+2)-'0')*10 + (*(pTe
             -mp+3)-'0');
 497   1              
 498   1              SysParamToEeprom();
 499   1      }
 500          
 501          void DebugWIFI(void)
 502          {
 503   1              WifiPrintf(&g_sUart[UART_PC].cReveiveBuf[1]);
 504   1      }
 505          
 506          void PrintOn(void)
 507          {
 508   1              if(g_sUart[UART_PC].iPushIndex > 1)
 509   1                      return;
 510   1              g_SystemParam.DebugInforOutput = ENABLE;
 511   1              SysParamToEeprom();
 512   1              SysPrintf( "\r\nDebug usart on!");
 513   1      }
 514          
 515          void PrintOff(void)
 516          {
 517   1              if(g_sUart[UART_PC].iPushIndex > 1)
 518   1                      return;
 519   1              g_SystemParam.DebugInforOutput = DISABLE;
 520   1              SysParamToEeprom();
 521   1              SysPrintf( "\r\nDebug usart off!");
 522   1      }
 523          
 524          Uart_Debug_t UartCMDFunSet[] =
 525          {
 526                  { 
 527                          "?",
 528                          CmdInquery,
 529                  },
 530                  
 531                  { 
 532                          "A",
 533                          PrintParam,
 534                  },
 535          
 536                  {
 537                          "B",
 538                          GPIOStatus,     
 539                  },
 540          
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 10  

 541                  {
 542                          "C",
 543                          SetIP,  
 544                  },
 545          
 546                  {
 547                          "D",
 548                          SetMuteStatus,  
 549                  },
 550                  
 551                  { 
 552                          "E",
 553                          DebugWIFI,
 554                  },
 555                  
 556                  {
 557                          "F",
 558                          PrintOn,        
 559                  },
 560          
 561                  { 
 562                          "G",
 563                          PrintOff,
 564                  },
 565                  
 566                  {
 567                          NULL,
 568                          NULL,
 569                  },      
 570          };
 571          
 572          
 573          void UartFromPC(void)
 574          {
 575   1              Uart_Debug_t *pTemp;
 576   1              
 577   1              pTemp = UartCMDFunSet;
 578   1              while(pTemp->fun!=NULL)
 579   1              {               
 580   2                      if(memcmp(g_sUart[UART_PC].cReveiveBuf, pTemp->UartCMD, 1)==0)
 581   2                      {
 582   3                              pTemp->fun();
 583   3                              break;
 584   3                      }
 585   2                      pTemp++;
 586   2              }
 587   1      
 588   1               ClearUartBuffer(UART_PC);
 589   1      }
 590          
 591          void UartReceiveHandler(MSG_t *pMsg)
 592          {
 593   1              SysPrintf("\r\nUart %xi receive handler.", pMsg->Param);
 594   1              if(pMsg->Param == UART_PC) //debug uart
 595   1              {
 596   2                      UartFromPC();
 597   2                      g_sUart[UART_PC].bRxControl = ENABLE;
 598   2              }
 599   1              else if(pMsg->Param == UART_WIFI) 
 600   1              {
 601   2                      WifiReceiveDataHandle();
 602   2                      g_sUart[UART_WIFI].bRxControl = ENABLE;
C51 COMPILER V9.00   UART                                                                  11/07/2015 14:53:11 PAGE 11  

 603   2              }
 604   1      }
 605          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4276    ----
   CONSTANT SIZE    =   1596    ----
   XDATA SIZE       =    614      98
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
